diff -ruNa gcc-3.3.3-orig/gcc/config/mips/mips.c gcc-3.3.3/gcc/config/mips/mips.c
--- gcc-3.3.3-orig/gcc/config/mips/mips.c	2003-06-27 11:44:23.000000000 +0000
+++ gcc-3.3.3/gcc/config/mips/mips.c	2004-05-17 13:40:06.000000000 +0000
@@ -4029,34 +4029,6 @@
 	  bytes -= 8;
 	}
 
-      /* ??? Fails because of a MIPS assembler bug?  */
-      else if (TARGET_64BIT && bytes >= 8
-	       && ! TARGET_SR71K
-	       && ! TARGET_MIPS16)
-	{
-	  if (BYTES_BIG_ENDIAN)
-	    {
-	      load_store[num].load = "ldl\t%0,%1\n\tldr\t%0,%2";
-	      load_store[num].load_nop = "ldl\t%0,%1\n\tldr\t%0,%2%#";
-	      load_store[num].store = "sdl\t%0,%1\n\tsdr\t%0,%2";
-	      load_store[num].last_store = "sdr\t%0,%2";
-	      load_store[num].final = "sdl\t%0,%1";
-	    }
-	  else
-	    {
-	      load_store[num].load = "ldl\t%0,%2\n\tldr\t%0,%1";
-	      load_store[num].load_nop = "ldl\t%0,%2\n\tldr\t%0,%1%#";
-	      load_store[num].store = "sdl\t%0,%2\n\tsdr\t%0,%1";
-	      load_store[num].last_store = "sdr\t%0,%1";
-	      load_store[num].final = "sdl\t%0,%2";
-	    }
-
-	  load_store[num].mode = DImode;
-	  offset += 8;
-	  bytes -= 8;
-	  use_lwl_lwr = 1;
-	}
-
       else if (bytes >= 4 && align >= 4)
 	{
 	  load_store[num].load = "lw\t%0,%1";
@@ -4069,33 +4041,6 @@
 	  bytes -= 4;
 	}
 
-      else if (bytes >= 4
-	       && ! TARGET_SR71K
-	       && ! TARGET_MIPS16)
-	{
-	  if (BYTES_BIG_ENDIAN)
-	    {
-	      load_store[num].load = "lwl\t%0,%1\n\tlwr\t%0,%2";
-	      load_store[num].load_nop = "lwl\t%0,%1\n\tlwr\t%0,%2%#";
-	      load_store[num].store = "swl\t%0,%1\n\tswr\t%0,%2";
-	      load_store[num].last_store = "swr\t%0,%2";
-	      load_store[num].final = "swl\t%0,%1";
-	    }
-	  else
-	    {
-	      load_store[num].load = "lwl\t%0,%2\n\tlwr\t%0,%1";
-	      load_store[num].load_nop = "lwl\t%0,%2\n\tlwr\t%0,%1%#";
-	      load_store[num].store = "swl\t%0,%2\n\tswr\t%0,%1";
-	      load_store[num].last_store = "swr\t%0,%1";
-	      load_store[num].final = "swl\t%0,%2";
-	    }
-
-	  load_store[num].mode = SImode;
-	  offset += 4;
-	  bytes -= 4;
-	  use_lwl_lwr = 1;
-	}
-
       else if (bytes >= 2 && align >= 2)
 	{
 	  load_store[num].load = "lh\t%0,%1";
diff -ruNa gcc-3.3.3-orig/gcc/config/mips/mips.md gcc-3.3.3/gcc/config/mips/mips.md
--- gcc-3.3.3-orig/gcc/config/mips/mips.md	2003-06-27 11:44:22.000000000 +0000
+++ gcc-3.3.3/gcc/config/mips/mips.md	2004-05-18 07:39:02.000000000 +0000
@@ -4879,7 +4879,8 @@
 
   /* Otherwise, emit a l[wd]l/l[wd]r pair to load the value.  */
   if (INTVAL (operands[2]) == 64)
-    emit_insn (gen_movdi_uld (operands[0], operands[1]));
+  /* patent-free */
+		FAIL;
   else
     {
       if (TARGET_64BIT)
@@ -4888,7 +4889,8 @@
 	  if (operands[0] == NULL_RTX)
 	    FAIL;
 	}
-      emit_insn (gen_movsi_ulw (operands[0], operands[1]));
+    /* patent-free */
+		FAIL;
     }
   DONE;
 }")
@@ -4928,7 +4930,8 @@
 
   /* Otherwise, emit a lwl/lwr pair to load the value.  */
   if (INTVAL (operands[2]) == 64)
-    emit_insn (gen_movdi_uld (operands[0], operands[1]));
+    /* patent-free */
+		FAIL;
   else
     {
       if (TARGET_64BIT)
@@ -4937,7 +4940,8 @@
 	  if (operands[0] == NULL_RTX)
 	    FAIL;
 	}
-      emit_insn (gen_movsi_ulw (operands[0], operands[1]));
+      /* patent-free */
+		FAIL;
     }
   DONE;
 }")
@@ -4977,7 +4981,8 @@
 
   /* Otherwise, emit a s[wd]l/s[wd]r pair to load the value.  */
   if (INTVAL (operands[1]) == 64)
-    emit_insn (gen_movdi_usd (operands[0], operands[3]));
+    /* patent-free */
+		FAIL;
   else
     {
       if (TARGET_64BIT)
@@ -4986,131 +4991,12 @@
 	  if (operands[3] == NULL_RTX)
 	    FAIL;
 	}
-      emit_insn (gen_movsi_usw (operands[0], operands[3]));
+      /* patent-free */
+		FAIL;
     }
   DONE;
 }")
 
-;; unaligned word moves generated by the bit field patterns
-
-(define_insn "movsi_ulw"
-  [(set (match_operand:SI 0 "register_operand" "=&d,&d")
-	(unspec:SI [(match_operand:BLK 1 "general_operand" "R,o")]
-		   UNSPEC_ULW))]
-  "!TARGET_MIPS16"
-  "*
-{
-  rtx offset = const0_rtx;
-  rtx addr = XEXP (operands[1], 0);
-  rtx mem_addr = eliminate_constant_term (addr, &offset);
-  const char *ret;
-
-  if (TARGET_STATS)
-    mips_count_memory_refs (operands[1], 2);
-
-  /* The stack/frame pointers are always aligned, so we can convert
-     to the faster lw if we are referencing an aligned stack location.  */
-
-  if ((INTVAL (offset) & 3) == 0
-      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))
-    ret = \"lw\\t%0,%1\";
-  else
-    ret = \"ulw\\t%0,%1\";
-
-  return mips_fill_delay_slot (ret, DELAY_LOAD, operands, insn);
-}"
-  [(set_attr "type"	"load,load")
-   (set_attr "mode"	"SI")
-   (set_attr "length"	"8,16")])
-
-(define_insn "movsi_usw"
-  [(set (match_operand:BLK 0 "memory_operand" "=R,o")
-	(unspec:BLK [(match_operand:SI 1 "reg_or_0_operand" "dJ,dJ")]
-		    UNSPEC_USW))]
-  "!TARGET_MIPS16"
-  "*
-{
-  rtx offset = const0_rtx;
-  rtx addr = XEXP (operands[0], 0);
-  rtx mem_addr = eliminate_constant_term (addr, &offset);
-
-  if (TARGET_STATS)
-    mips_count_memory_refs (operands[0], 2);
-
-  /* The stack/frame pointers are always aligned, so we can convert
-     to the faster sw if we are referencing an aligned stack location.  */
-
-  if ((INTVAL (offset) & 3) == 0
-      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))
-    return \"sw\\t%z1,%0\";
-
-  return \"usw\\t%z1,%0\";
-}"
-  [(set_attr "type"	"store")
-   (set_attr "mode"	"SI")
-   (set_attr "length"	"8,16")])
-
-;; Bit field extract patterns which use ldl/ldr.
-
-;; unaligned double word moves generated by the bit field patterns
-
-(define_insn "movdi_uld"
-  [(set (match_operand:DI 0 "register_operand" "=&d,&d")
-	(unspec:DI [(match_operand:BLK 1 "general_operand" "R,o")]
-		   UNSPEC_ULD))]
-  ""
-  "*
-{
-  rtx offset = const0_rtx;
-  rtx addr = XEXP (operands[1], 0);
-  rtx mem_addr = eliminate_constant_term (addr, &offset);
-  const char *ret;
-
-  if (TARGET_STATS)
-    mips_count_memory_refs (operands[1], 2);
-
-  /* The stack/frame pointers are always aligned, so we can convert
-     to the faster lw if we are referencing an aligned stack location.  */
-
-  if ((INTVAL (offset) & 7) == 0
-      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))
-    ret = \"ld\\t%0,%1\";
-  else
-    ret = \"uld\\t%0,%1\";
-
-  return mips_fill_delay_slot (ret, DELAY_LOAD, operands, insn);
-}"
-  [(set_attr "type"	"load,load")
-   (set_attr "mode"	"SI")
-   (set_attr "length"	"8,16")])
-
-(define_insn "movdi_usd"
-  [(set (match_operand:BLK 0 "memory_operand" "=R,o")
-	(unspec:BLK [(match_operand:DI 1 "reg_or_0_operand" "dJ,dJ")]
-		    UNSPEC_USD))]
-  ""
-  "*
-{
-  rtx offset = const0_rtx;
-  rtx addr = XEXP (operands[0], 0);
-  rtx mem_addr = eliminate_constant_term (addr, &offset);
-
-  if (TARGET_STATS)
-    mips_count_memory_refs (operands[0], 2);
-
-  /* The stack/frame pointers are always aligned, so we can convert
-     to the faster sw if we are referencing an aligned stack location.  */
-
-  if ((INTVAL (offset) & 7) == 0
-      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))
-    return \"sd\\t%z1,%0\";
-
-  return \"usd\\t%z1,%0\";
-}"
-  [(set_attr "type"	"store")
-   (set_attr "mode"	"SI")
-   (set_attr "length"	"8,16")])
-
 ;; These two patterns support loading addresses with two instructions instead
 ;; of using the macro instruction la.
 
